<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Detect cycle in directed graph]]></title>
      <url>http://darrencheng0817.github.io/2016/03/12/Detect-cycle-in-directed-graph/</url>
      <content type="html"><![CDATA[<hr>
<p>Detecting cycle in undirected graph has been discussed in the <a href="http://blog.darrenlife.com/2016/03/11/Detect-cycle-in-undirected-graph/" target="_blank" rel="external">previous post</a>. Now let’s see what happened if it is a directed graph.<br><a id="more"></a>  </p>
<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>The original BFS and DFS are not working here. Consider the following graph:<br><img src="/images/2016_3_12/1.png" alt="Example graph" width="100" hight="200"><br>There is not cycle in the graph, however, if you do a BFS or DFS, you will get wrong answer. Let’s say you do DFS start from A, then A-&gt;B-&gt;C. Then you go to C from A, found that C is already visited. The algorithm will return ture but there is no cycle.</p>
<h1 id="Modified-DFS"><a href="#Modified-DFS" class="headerlink" title="Modified DFS"></a>Modified DFS</h1><p>DFS can be used to detect cycle in a Graph instead of BFS. Because DFS for a connected graph produces a tree. There is a cycle in a graph only if there is a back edge present in the graph. A back edge is an edge that is from a node to itself (selfloop) or one of its ancestor in the tree produced by DFS. </p>
<p>To detect a back edge, we can keep track of vertices currently in recursion stack of function for DFS traversal. If we reach a vertex that is already in the recursion stack, then there is a cycle in the tree. The edge that connects current vertex to the vertex in the recursion stack is back edge. We use an array to keep track of vertices in the recursion stack. </p>
<h2 id="Python-code"><a href="#Python-code" class="headerlink" title="Python code:"></a>Python code:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle_dectector_dfs</span><span class="params">(edges)</span>:</span></span><br><span class="line">    graph,in_degree=build_graph(edges)</span><br><span class="line">    visited=set()</span><br><span class="line">    rec_stack=set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(point)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> point <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        visited.add(point)</span><br><span class="line">        rec_stack.add(point)</span><br><span class="line">        <span class="keyword">for</span> to_point <span class="keyword">in</span> graph[point]:</span><br><span class="line">            <span class="keyword">if</span> to_point <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> <span class="keyword">not</span> dfs(to_point):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">elif</span> to_point <span class="keyword">in</span> rec_stack:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        rec_stack.remove(point)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span>   </span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> graph.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dfs(point):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>      </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_graph</span><span class="params">(edges)</span>:</span></span><br><span class="line">    graph=&#123;&#125;</span><br><span class="line">    in_degree=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> from_point,to_point <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> from_point <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">            graph[from_point]=[]</span><br><span class="line">        <span class="keyword">if</span> to_point <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">            graph[to_point]=[]</span><br><span class="line">        graph[from_point].append(to_point)</span><br><span class="line">        <span class="keyword">if</span> from_point <span class="keyword">not</span> <span class="keyword">in</span> in_degree:</span><br><span class="line">            in_degree[from_point]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> to_point <span class="keyword">not</span> <span class="keyword">in</span> in_degree:</span><br><span class="line">            in_degree[to_point]=<span class="number">0</span></span><br><span class="line">        in_degree[to_point]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> graph,in_degree</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">edges=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">print(circle_dectector_dfs(edges))</span><br></pre></td></tr></table></figure>
<p>The algorithm runs in O(V+E) time.</p>
<h1 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h1><p>Topological Sort is a other way to detect cycle in directed graph.</p>
<blockquote>
<p>In the field of computer science, a topological sort (sometimes abbreviated toposort[1]) or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering.</p>
</blockquote>
<p>If a Topological Sort exist for a directed graph, then the graph contains no cycle. Otherwise the cycle exist.</p>
<blockquote>
<p>One algorithm, first described by Kahn (1962), works by choosing vertices in the same order as the eventual topological sort. First, find a list of “start nodes” which have no incoming edges and insert them into a set S; at least one such node must exist in a non-empty acyclic graph. Then:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L ← Empty list that will contain the sorted elements</span><br><span class="line">S ← Set of all nodes with no incoming edges</span><br><span class="line">while S is non-empty do</span><br><span class="line">    remove a node n from S</span><br><span class="line">    add n to tail of L</span><br><span class="line">    for each node m with an edge e from n to m do</span><br><span class="line">        remove edge e from the graph</span><br><span class="line">        if m has no other incoming edges then</span><br><span class="line">            insert m into S</span><br><span class="line">if graph has edges then</span><br><span class="line">    return error (graph has at least one cycle)</span><br><span class="line">else </span><br><span class="line">    return L (a topologically sorted order)</span><br></pre></td></tr></table></figure>
<h2 id="Python-code-1"><a href="#Python-code-1" class="headerlink" title="Python code"></a>Python code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle_dectector</span><span class="params">(edges)</span>:</span></span><br><span class="line">    graph,in_degree=build_graph(edges)</span><br><span class="line">    queue=[start_point <span class="keyword">for</span> start_point <span class="keyword">in</span> in_degree.keys() <span class="keyword">if</span> in_degree[start_point]==<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        from_point=queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> to_point <span class="keyword">in</span> graph[from_point]:</span><br><span class="line">            in_degree[to_point]-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> in_degree[to_point]==<span class="number">0</span>:</span><br><span class="line">                queue.append(to_point)</span><br><span class="line">        graph.pop(from_point)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> bool(graph)</span><br></pre></td></tr></table></figure>
<p>This also runs in O(V+E) liner time.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Detect cycle in undirected graph]]></title>
      <url>http://darrencheng0817.github.io/2016/03/11/Detect-cycle-in-undirected-graph/</url>
      <content type="html"><![CDATA[<hr>
<p>In this post, I will discuss how to detect cycle in undirected graph using BFS, DFS and Union-Find.<br><a id="more"></a>  </p>
<h1 id="BFS-or-DFS"><a href="#BFS-or-DFS" class="headerlink" title="BFS or DFS"></a>BFS or DFS</h1><p>It is very easy to detect cycle in a undirected graph, simple BFS or DFS should work. Use a set to cache the nodes that have been visited. Then during the traversal, if current visiting node is alreadly in the set, there must be a cycle in the graph.</p>
<h2 id="Python-code"><a href="#Python-code" class="headerlink" title="Python code:"></a>Python code:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle_dectector</span><span class="params">(edges,start_point)</span>:</span></span><br><span class="line">    graph=build_graph(edges)</span><br><span class="line">    queue=[start_point]</span><br><span class="line">    visited=set()</span><br><span class="line">    visited.add(queue[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        from_point=queue.pop(<span class="number">0</span>)<span class="comment">#BFS</span></span><br><span class="line">        <span class="comment"># from_point=queue.pop(0) #DFS</span></span><br><span class="line">        <span class="keyword">for</span> to_point <span class="keyword">in</span> graph[from_point]:</span><br><span class="line">            <span class="keyword">if</span> to_point <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(to_point)</span><br><span class="line">                visited.add(to_point)</span><br><span class="line">            graph[to_point].remove(from_point)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_graph</span><span class="params">(edges)</span>:</span></span><br><span class="line">    graph=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> from_point,to_point <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> from_point <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">            graph[from_point]=set()</span><br><span class="line">        <span class="keyword">if</span> to_point <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">            graph[to_point]=set()</span><br><span class="line">        graph[from_point].add(to_point)</span><br><span class="line">        graph[to_point].add(from_point)</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">        </span><br><span class="line">edges=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">print(circle_dectector(edges),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>I use adjcent list to store the graph. The time complexity is O(V+E) time.</p>
<p>The above code works for connected graph. For a disconnected graph, you could call the function for every point as the start point. Or you could put one point in each component in the queue initially.</p>
<h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union-Find"></a>Union-Find</h1><p>The content will come soon.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[First post]]></title>
      <url>http://darrencheng0817.github.io/2016/03/11/First-post/</url>
      <content type="html"><![CDATA[<hr>
<p>Welcome to Darren’s blog! </p>
<p>This static website is built by <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>, which is a node.js framework. The website is hosted both on github pages and coding.net(For chinese visitors). So for visitors in China, please go to the <a href="http://darrencheng.coding.me/" target="_blank" rel="external">mirror site</a> which is faster.</p>
<p>I will write some technique posts or some moments about my life.</p>
<p>Fight on!</p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[404]]></title>
      <url>http://darrencheng0817.github.io//404.html</url>
      <content type="html"><![CDATA[<hr>
<p><style type="text/css"><br>    .article-header {<br>        padding: 0;<br>        padding-top: 26px;<br>        border-left: none;<br>        text-align: center;<br>    }<br>    .article-header:hover {<br>        border-left: none;<br>    }<br>    .article-title {<br>        font-size: 2.1em;<br>    }<br>    strong a {<br>        color: #747474;<br>    }<br>    .article-meta {<br>        display: none;<br>    }<br>    .share {<br>        display: none;<br>    }<br>    .ds-meta {<br>        display: none;<br>    }<br>    .player {<br>        margin-left: -10px;<br>    }<br>    .sign {<br>        text-align: right;<br>        font-style: italic;<br>    }</p>
<pre><code>  #page-visit {
    display: none;
}
.center {
    text-align: center;
    height: 2.5em;
    font-weight: bold;
}
.article-entry hr {
    margin: 0;
}
.pic {
    text-align: center;
    margin: 0;
}
.pic br {
      display: none;
  }
#container .article-info-post.article-info {
  display: none;
  }
#container .article .article-title {
padding: 0;
}
.share{
    display: none;
}
</code></pre><p></style></p>
<p><div style="text-align:center"><br><img src="/images/404.png" alt="404" width="400" hight="200"><br></div></p>
<h2 id="Search-what-you-want"><a href="#Search-what-you-want" class="headerlink" title="Search what you want"></a>Search what you want</h2><p><div style="text-align: center"><br>    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search articles here!" style="margin-bottom:1em;width:100%"><br></div></p>
<p><div id="local-search-result"></div></p>
<script src="/js/search.js"></script> 
<script type="text/javascript">      
 var path = "/search.xml";
 searchFunc(path, 'local-search-input', 'local-search-result');
</script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Search]]></title>
      <url>http://darrencheng0817.github.io/Search/index.html</url>
      <content type="html"><![CDATA[<h2 id="Search-what-you-want"><a href="#Search-what-you-want" class="headerlink" title="Search what you want"></a>Search what you want</h2><p><div style="text-align: center"><br>    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search articles here!" style="margin-bottom:1em;width:100%"><br></div></p>
<p><div id="local-search-result"></div></p>
<script src="/js/search.js"></script> 
<script type="text/javascript">      
 var path = "/search.xml";
 searchFunc(path, 'local-search-input', 'local-search-result');
</script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[About]]></title>
      <url>http://darrencheng0817.github.io/about/index.html</url>
      <content type="html"><![CDATA[<hr>
<p>The site was built on Mar.11, 2016 using <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>, which is a node.js framework. The website is hosted both on github pages and coding.net (For chinese visitors). So for visitors in China, please go to the <a href="http://darrencheng.coding.me/" target="_blank" rel="external">mirror site</a> which is faster.</p>
<a id="more"></a>
<h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><h2 id="3-14-2016-Custom-404"><a href="#3-14-2016-Custom-404" class="headerlink" title="[3/14/2016] Custom 404"></a>[3/14/2016] Custom 404</h2><ol>
<li>Added custom 404 page.</li>
</ol>
<h2 id="3-13-2016-Top-amp-Search"><a href="#3-13-2016-Top-amp-Search" class="headerlink" title="[3/13/2016] Top &amp; Search"></a>[3/13/2016] Top &amp; Search</h2><ol>
<li>Added top function, modified generator.js to sort posts first by top value, then date. Advised by <a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">Netcan</a>.</li>
<li>Added Search function.</li>
</ol>
<h2 id="3-12-2016-Custom-domain"><a href="#3-12-2016-Custom-domain" class="headerlink" title="[3/12/2016] Custom domain"></a>[3/12/2016] Custom domain</h2><ol>
<li>Modified DNS, created A record, pointing subdomain blog.darrenlife.com to github pages.</li>
<li>My nameserver(NS) could not differentiate traffice from China or overseas, so the mirror site for Chinese visitors will use address of <a href="http://darrencheng.coding.me" target="_blank" rel="external">darrencheng.coding.me</a></li>
<li>Added js script on my <a href="http://darrenlife.com" target="_blank" rel="external">front page</a> to identify visitors’ location, redirect them to China mirror site if they come from China.</li>
</ol>
<h2 id="3-11-2016-Theme-amp-Host"><a href="#3-11-2016-Theme-amp-Host" class="headerlink" title="[3/11/2016] Theme &amp; Host"></a>[3/11/2016] Theme &amp; Host</h2><ol>
<li>Hexo theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">Yelee</a> was used.</li>
<li>The website was hosted both on github pages and coding.net</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://darrencheng0817.github.io/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Me]]></title>
      <url>http://darrencheng0817.github.io/me/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
